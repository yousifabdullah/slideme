**Yleisrakenne:**

* Ohjelman suoritus alkaa graafisen käyttöliittymän käynnistyksellä, joka tuo esiin sekoitetussa järjestyksessä olevat peliruudut, jotka on saatava taas järjestykseen. Pelaaja voi siirtää peliruutuja sekä sekoittaa niiden järjestystä uuden pelitilanteen luomiseksi.

  * Sekoitusalgoritmina käytin Durstenfeldin algoritmia, joka on modernimpi vedos Fisher-Yates-algoritmista ja toimii O(n) aikavaativuudella. Koska pelkkä sekoitus ei kuitenkaan riitä ja on taattava parillinen inversioiden määrä lopulliselle järjestykselle, käytin bubble sort -järjestysalgoritmia tukena.

  * 8-pelin kaikki pelitilanteet voidaan jakaa kahteen ekvivalenssiluokkaan: niihin, joissa on parillinen määrä inversioita ja niihin, joissa on pariton määrä inversioita. Siis kaikki ratkaistavissa olevat pelitilanteet noudattavat rakennetta, jossa on parillinen määrä inversioita. Tämän takia pahimmassa tapauksessa O(n^2) aikavaativuudella toimiva bubble sort -algoritmi tuli tarpeen. En toteuttanut muuta algoritmia, koska erityisesti projektiani varten se soveltui hyvin. Esim. on huomioitava, että pelitilanne säilytetään taulukkona, jossa 0 merkitsee vapaaruutua, eikä lukua 0. Toisin sanoen inversioita ei lasketa niille pareille, joissa i < j, A[i] > A[j] ja A[j] == 0 annetulla taulukolla A.

* Pelaaja voi myös käynnistää tekoälyn simulaation, joka visuaalisesti ratkaisee pelitilanteen askel askeleelta käyttäen A*-algoritmia.
  * A*-algoritmin toteutus käyttäen peliruutujen Manhattan-etäisyyttä heuristiikkana on keskeinen osa projektia. Sen aikavaativuus on O(|V| + |E|) ja toimii käytännössä nopeasti, useimmiten alle 200 millisekunnissa. Käytin erityisesti algoritmin suunnittelua varten seuraavaa lähdettä: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html.
  * Hakualgoritmi on myös halutessaan muutettavissa, kuitenkin niin että algoritmin sijasta vaikutetaan sen heuristiseen funktioon, joka puolestaan muuttaa algoritmin käyttäytymistä. Tässä erikoistapauksessa hakualgoritmi käyttäytyy siis samalla tavalla, kuin esim. Dijkstran algoritmi, koska solmuja ei erikseen priorisoida arvioidun etäisyyden perusteella eli heuristiikka jätetään oikeastaan huomioimatta. Koska kuitenkin 8-peli toteuttaa omanlaisen erikoistapauksensa, jossa kaarten etäisyys on aina 1, toimii hakualgoritmi best-first -menetelmää noudattaen, siis BFS-algoritmin mukaisesti. Vaikka tämä jokseenkin nopeuttaa heuristista funktiota vakioaikaiseksi aikavaativuudesta O(n), on heuristiikasta hyötyä A*-algoritmia ajatellen, minkä vuoksi erityistä hajontaa suorituskyvyssä algoritmien välillä ei ole.