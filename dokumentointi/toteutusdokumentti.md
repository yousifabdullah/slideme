**Yleisrakenne:**

* Ohjelman suoritus alkaa graafisen käyttöliittymän käynnistyksellä, joka tuo esiin sekoitetussa järjestyksessä olevat peliruudut, jotka on saatava taas järjestykseen. Pelaaja voi siirtää peliruutuja sekä sekoittaa niiden järjestystä uuden pelitilanteen luomiseksi.

  * Sekoitusalgoritmina käytin Durstenfeldin algoritmia, joka on modernimpi vedos Fisher-Yates-algoritmista ja toimii O(n)-aikavaativuudella. Koska pelkkä sekoitus ei kuitenkaan riitä ja on taattava parillinen inversioiden määrä lopulliselle järjestykselle, käytin bubble sort -järjestysalgoritmia tukena.

  * 8-pelin kaikki pelitilanteet voidaan jakaa kahteen ekvivalenssiluokkaan: niihin, joissa on parillinen määrä inversioita ja niihin, joissa on pariton määrä inversioita. Siis kaikki ratkaistavissa olevat pelitilanteet noudattavat rakennetta, jossa on parillinen määrä inversioita. Tämän takia pahimmassa tapauksessa O(n^2)-aikavaativuudella toimiva bubble sort -algoritmi tuli tarpeen. En toteuttanut muuta algoritmia, koska erityisesti projektiani varten se soveltui hyvin. Esim. on huomioitava, että pelitilanne säilytetään taulukkona, jossa 0 merkitsee vapaaruutua, eikä lukua 0. Toisin sanoen inversioita ei lasketa niille pareille, joissa i < j, A[i] > A[j] ja A[j] = 0 annetulla taulukolla A.

* Pelaaja voi myös käynnistää tekoälyn simulaation, joka visuaalisesti ratkaisee pelitilanteen askel askeleelta käyttäen hakualgoritmia, joka käytössä olevan heuristiikan perusteella noudattaa A*- tai BFS-algoritmin toimintaa.

  * A*-algoritmin toteutus käyttäen peliruutujen Manhattan-etäisyyttä heuristiikkana on toinen vaihtoehdoista. Sen aikavaativuus on O(|V| + |E|) ja toimii käytännössä nopeasti pelitilanteen ratkaisemiseen, useimmiten alle 200 millisekunnissa. Käytin erityisesti algoritmin suunnittelua varten seuraavaa lähdettä: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html.

  * Hakualgoritmin heuristiikka on myös muutettavissa, joka vaikuttaa algoritmin käyttäytymiseen. Tässä erikoistapauksessa hakualgoritmi noudattaa samaa toimintaperiaatetta kuin esim. Dijkstran algoritmi, jossa solmuja ei erikseen priorisoida arvioidun etäisyyden perusteella. Koska 8-peli toteuttaa omanlaisen erikoistapauksensa, jossa kaarten etäisyys on aina 1, toimii hakualgoritmi oikeastaan best-first -menetelmää noudattaen, siis BFS-algoritmin mukaisesti. Vaikka tämä jokseenkin nopeuttaa heuristista funktiota vakioaikaiseksi aikavaativuudesta O(n), on algoritmi enimmäkseen samalla linjalla A*-algoritmin kanssa todellisessa suorituskyvyssä.

**Analyysi:**

* Hakualgoritmi käyttää heuristiikasta riippumatta kahta tietorakennetta apunaan: UniqueSet ja MinHeap. Aiempi on erikoistietorakenne, jonka suunnittelin erityisesti 8-peliä varten. Se korvaa hajautustaulun (esim. HashSet) ja takaa vakioaikaiset toiminnot O(n)-tilavaativuudella. MinHeap on nimensä mukaisesti minimikeko, jonka korjaaminen tapahtuu O(n)- ja lisäys O(log n)-aikavaativuudella. Käytin tietorakenteen lähteenä tira-kurssin materiaalia. Hakualgoritmin käyttämän heuristisen funktion aikavaativuus on pahimmassa tapauksessa myös O(n).

  * Toisin sanoen hakualgoritmi toteuttaa tavoitteen eli aikavaativuuden O(|V| + |E|), koska erityisesti algoritmin tukena tapahtuvat toiminnot eivät ylitä O(n)-aikavaativuutta. Hakualgoritmi siis käy tarvittaessa kaikki solmut ja kaaret läpi ja koska O(|E|) voi vaihdella O(1) ja O(|V|^2) välillä, on algoritmin aikavaativuus todellisuudessa O(|V|^2) mukainen.

  * A*-algoritmin todellinen suorituskyky ei eroa erityisemmin BFS-algoritmin suorituskyvystä, mutta algoritmien välillä on havaittavissa erilainen käyrä suorituskyvyn toteutumisessa. Erityisesti BFS-algoritmi toimii käytännössä nopeammin ja kasvaa suhteessa iteraatioihin nähden tasaisesti. Tämä on perusteltavissa sillä, että käytetty heuristinen funktio eli Manhattan-etäisyys vaatii O(n)-aikavaativudella toimivan pelitilanteen läpikäynnin, kun taas BFS-algoritmissa heuristinen funktio on vakioaikainen.

* Koska pelitilanne nykyisin tallennetaan int[]-taulukkona, johon sisällytetään vapaaruutu lukuna 0, aiheutuu siitä sekoitusalgoritmin osalta inversioiden laskeminen vähemmän toivotulla tehokkuudella. Vaihtoehtoinen tapa olisi säilyttää vapaaruudun sijainti erikseen ja tallentaa pelitilanne ilman vapaaruutua, mikä tekisi rungosta kuitenkin hieman monimutkaisemman. Siitä huolimatta olisi mahdollista korvata inversioiden laskemiseen käytetty bubble sort esim. merge sort -algoritmilla, jolloin pelitilanteen sekoitus inversioiden tarkistuksen kanssa olisi pahimmassa tapauksessa O(n log n)-aikavaativuuden toiminto.

  * Huom. tämä optimointi auttaisi vain 8-pelin toteutuksessa, koska erityisesti 15-pelin tapauksessa ekvivalenssiluokkia on useampia ja pelkkä inversioiden määrä ei vielä kerro, onko pelitilanne ratkaistavissa. Toisaalta esim. 15-pelin kohdalla mikään muu hakualgoritmi A*-algoritmin ohella ei ole suotava, koska läpikäytäviä iteraatioita on huomattavasti enemmän 8-peliin nähden.

* Mikäli heuristiikan vaikutusta hakualgoritmin suorituskykyyn haluaisi tutkia syvemmin, olisi selkeä parannus vapaasti muokattavissa oleva heuristinen funktio, jonka voisi ohjelmoida ennen tekoälyn simulaation käynnistämistä. Tällöin voisi kokeilla esim. eri tapoja laskea Manhattan-etäisyyden tai käyttää kokonaan erilaista heuristiikkaa. Nykyinen toteutus on tässä suhteessa suppea, mutta toisaalta tällainen parannus vaatisi selkeästi enemmän aikaa ja erityisesti testaamista. Samalla olisi kuitenkin mahdollista laajentaa projektia niin, että se käyttäisi myös tehokkaampaa hakualgoritmia, joka yhdistäisi esim. A*-algoritmin ja DFS-algoritmin toimintaperiaatteet. Esim. 15-pelin tapauksessa juuri tällainen iteraatioiden mukaisesti syventyvä hakualgoritmi tulisi tarpeen, koska muilla algoritmeilla suorituskyky alkaisi kärsiä oleellisesti. Seuraava askel projektille olisi kuitenkin laajentaa sen toimintaa edellämainittujen ehdotusten mukaisesti, jolloin projektista tulisi samalla selkeästi laajempi.