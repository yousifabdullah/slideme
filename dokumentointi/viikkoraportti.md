*Viikko 1:*

* Ensimmäisellä viikolla tutustuin erityisesti GitHubiin sekä alustin Git- ja NetBeans-ympäristön projektia varten. Käytin aikaa projektin määrittelydokumentin laatimiseen sekä lähteiden tutkimiseen, päätyen yhteen varsin kattavaan lähteeseen, jota tulen käyttämään pääasiallisesti projektin ohjenuorana. Opin käyttämään versionhallintaa alustavasti, vaikka se on eri muodoissa ollut minulle tuttu (mm. Subversion ja CVS). Mitään ei ole vielä jäänyt epäselväksi ja koen, että projekti etenee kokonaisuudessaan juuri sopivalla tahdilla. Vaikka suoritan tiralabran yhdessä javalabran kanssa, on minulle selkeää, miten työni tulee toteuttaa ja mitä asioita vaaditaan niin tira- kuin javalabran osalta. Seuraavaksi on tarkoitus määritellä projektia entistä tarkemmin mm. luokkakaavion voimin sekä aloittaa jo graafisen käyttöliittymän hahmottelua. Tällä hetkellä en ole varma siitä, miten etenen koodin suhteen, eli sen selvittäminen seuraavaksi on myös tärkeää.

*Viikko 2:*

* Olen aloittanut koodin laatimisen ydinalueelta, eli pelitilanteen ylläpitävästä luokasta ja sen käyttämästä apuluokasta. Käytin aikaa erityisesti sopivien algoritmien löytämiseen ja niiden toteuttamiseen, koska peliä ajatellen algoritmien yleinen toteutus ei välttämättä toimi halutulla tavalla ja koodia on muokattava tarpeen mukaan. Nyt pelitilannetta on mahdollista ylläpitää omalla luokallaan ja sen voi sekoittaa aina halutessaan, kuitenkin niin ettei lopullinen pelitilanne ole mahdoton ratkaista. Koska jatkossa voin olettaa, että kaikki pelin aikana tapahtuvat tilanteet ovat ratkaistavissa, helpottuu myös algoritmien suunnittelu ja ennen pitkää tekoälyn toteutus. Opin tällä viikolla erityisesti sekoitusalgoritmeista, kuten Fisher-Yates-algoritmista ja tuoreemmasta Durstenfeldin toteutuksesta. Huomioni kiinnittyi mm. siihen, että yleinen "off by one error" voi kokonaan muuttaa sekoitusalgoritmin toiminnan, jolloin tässä tapauksessa siitä tulisi Sattolon algoritmi. Tulen tämän takia jatkossakin pitämään erityistä huolta oman koodini oikeellisuudesta, etten vahingossakaan tee vääriä oletuksia sen toiminnasta. Tästä huolimatta kaikki ei ollut yhtä selkeää: esim. inversioiden laskemiseen on monia useita ratkaisuja, joista aikavaativuudeltaan tehokkain hyödyntää merge sortia, mutta todellisuudessa yksinkertaisempi bubble sort voi olla yhtä pätevä. Siinä hyödynnetään tieto siitä, että bubble sort käyttää aina vähimmän mahdollisen määrän vierekkäisten alkioiden vaihtoja taulukkoa järjestäessään. Tämän lisäksi bubble sort oli mahdollista muokata peliini sopivaksi, kun taas merge sortia ei. Esim. pelitilannetta ajatellen inversioita ei lasketa niille pareille, joissa i < j, A[i] > A[j] ja A[j] == 0 annetulla taulukolla A, koska 0 merkitsee vapaaruutua eikä lukua 0. Merge sortia ei voinut yksinkertaisesti muokata toimimaan tällä tavalla, jolloin siitä tuli monimutkaisempi kuin nykyinen toteutus bubble sortilla. Seuraavaksi on aika toteuttaa käyttöliittymä koodin muodossa, käyttäen apuna laatimaani minimaalista konseptia siitä. Kun olen saanut käyttöliittymän ja pelin "ytimen" välillä tapahtuvan toiminnallisuuden aikaiseksi, voin aloittaa jo tekoälyn suunnittelun.

*Viikko 3:*

* Projektin rungon hiominen sekä käyttöliittymän toteutus olivat erityisesti tärkeitä tämän viikon kannalta. Peli on edistynyt jo pelattavaan muotoon eli tarvittava ydintoiminnallisuus on kunnossa hyvän graafisen käyttöliittymän kera. Vaikka käyttöliittymän toteutuksen olisi voinut jättää myöhemmälle, on se tässä projektissa keskeisessä roolissa. Esim. tekoälyn simulaatio tulee tapahtumaan visuaalisesti askel askeleelta, kunnes pelitilanne on saatettu ratkaistuun tilaan, minkä vuoksi on tärkeää jo nyt tietää, miten käyttöliittymä ylipäänsä toimii. Nyt voin keskittyä puhtaasti tekoälyn suunnitteluun, testaamiseen ja hiomiseen. Arvelisin, että 50% koko työstä on nyt tehty, jäljellä enää se toinen ja samalla tärkeämpi osuus, eli tekoäly. Opin hyvin paljon Swing-käyttöliittymien suunnittelusta ja valtaosa ajasta viikolla kului siihen että opin ymmärtämään, miksi jokin mielessäni toimiva ajatus ei kantaudu toimivaan muotoon koodissa. Erityisesti visuaalisten komponenttien kuten painikkeiden sijoittelu tuotti vaikeuksia, koska siihen on tarjolla lukuisia eri vaihtoehtoja, kuten BoxLayout, BorderLayout ja GridLayout. En suostunut käyttämään esim. NetBeansin omaa visuaalista suunnittelutyökalua, koska lopullinen koodi oli hirveä sekasotku, joka vaikutti myös suoritukseen. Tämän takia lähdin laatimaan käyttöliittymän koodia käsin päätyäkseni nykyiseen melko minimaaliseen toteutukseen, joka toimii kiitettävästi ja on lähellä aiemmin laatimaani konseptia. Seuraavaksi ryntään pää edellä tekoälyn kimppuun, eli palaan takaisin raakaan koodiin ja unohdan käyttöliittymän hetkeksi. Aluksi suunnittelen joko A* tai BFS algoritmin ja pyrin saamaan vähintään jollain tasolla toimivan koodin, jota voin myöhemmin hioa ja lopuksi liittää lopulliseen peliin osaksi nyt toteutettua käyttöliittymää.

*Viikko 4:*

* Olen edennyt juuri oman näkemykseni mukaisesti projektin suhteen ja nykyisellään projekti sisältää jo toimivan, vaikkakin alkeellisen version tekoälystä. Hyödynsin erityisesti uutta löytämääni lähdettä, joka avasi mm. heuristiikan käyttötapaukset hakualgoritmeissa ja miksi kaksiulotteisessa koordinaatistossa on parasta hyödyntää Manhattan-etäisyyttä. Laadin nykyistä toiminnallisuutta varten kaksi uutta luokkaa sekä kattavat yksikkötestit toiselle näistä luokista eli seuraavaksi on tarkoitus hioa ohjelmakoodia yhä enemmän sekä laatia BFS-toteutus tekoälylle. Se onnistuu onneksi helposti, koska kyseessä on lähinnä pieni muutos käytettyyn heuristiikkaan. Projektin ajatuksena onkin tutkia tekoälyn puolelta suorituskykyä eri algoritmeilla, tässä tapauksessa valitut algoritmit toimivat käytännön tasolla samalla lailla, mutta eroavat heuristiikassaan. Opin siis paljon erityisesti heuristisista funktioista tällä viikolla. Minulle jäi hieman epäselväksi tällä erää, miten minun kannattaisi toteuttaa simulaatio käyttöliittymässä visuaalisesti. Tällä hetkellä saan esiin polun, mitä pitkin vapaaruudun tulisi "kulkea" eli muita peliruutuja on siirrettävä, jotta vapaaruudun sijainti muuttuu halutusti. Välivaiheiden simulointi viiveellä ei onnistunut varhaisessa toteutuksessani Thread.sleep()-metodin avulla, eli se on seuraava haasteeni, kuin myös omien tietorakenteiden toteutus eli tässä tapauksessa minimikeko sekä hajautustaulu. Nämä eivät onneksi ole vaikeita toteuttaa, eli suurempaa pelkoa tulevasta ei vielä ole. Päinvastoin, projektini näyttää etenevän omasta mielestäni sopivasti.

*Viikko 5:*

* Omien tietorakenteiden toteutus on vihdoin valmis. Suorituskyvyn osalta erityisesti tilavaativuutta kasvattamalla pystyin luomaan O(1) aikavaativuudella toimivan erikoistietorakenteen, joka korvaa hajautustaulun hakualgoritmissa. Kriittisen optimoinnin ansiosta tilavaativuus on kuitenkin kurissa ja hakualgoritmi nyt huomattavasti nopeampi kuin aiemmalla toteutuksella hajautustaulun ja Javan HashSet-tietorakenteen avulla. Suorituskykytestauksen osalta tuli vastaan kuitenkin hämmennystä, koska osa tuloksista vaikuttivat tavallista huonommilta. Sitä on tutkittava seuraavaksi, kuten ehdin jo testausdokumentissa pohtia. Tekoälyä on hiottu siihen kuntoon, että ainoastaan kattavat kommentit koodiin riittävät, jotta voin jatkaa seuraavaan ja lopulliseen osaan projektissani: simulaatioon. Tällä hetkellä simulaatio "tapahtuu" niin nopeasti, että napinpainalluksen jälkeen käyttäjän eteen tulee valmis ratkaisu, mikä ei tietenkään ole hyvä asia. Olenkin tutustunut Timer-luokkaan tarkemmin ja mielessäni on tapa toteuttaa simulaatio halutulla tavalla. Väittäisin projektin olevan jo 95% valmis, eli varsinainen työ on vain päivittää dokumentaatio kauttaaltaan ja käydä kaikki kirjoittamani kommentit koodissa läpi virheiden varalta. Kaikkea tätä ennen siis ensiksi simulaatio on saatava toimintakuntoon ja suorituskykytestaukseen liittyvät huolenaiheet selvitettävä. Olen omasta mielestäni hyvin tyytyväinen projektin nykyiseen rakenteeseen, joka nykyisin toimii laatimani luokkakaavion sekä sekvenssikaavioiden kuvaamalla tavalla.